[{"content":"神经元 $$ z = g(a_1 * W_1 + a_2 * W_2 + a_3 * W_3) $$$$ \\text{sgn}(x) = \\begin{cases} 1, \u0026 x \\geq 0 \\\\ 0, \u0026 x \u003c 0 \\end{cases} $$ 其中的x表示加权输入的总和，当输入总和$\\geq0$时，神经元输出1(被激活)，否则输出0(未激活)。\n将sum、sgn绘制在一起表示神经元的内部计算。单个神经元可以引出多个相同值的有向箭头。\n神经元模型的目标是什么？\n神经元的目标是学习一个最优的计算规则，让输入数据经过它后，能尽可能准确地预测输出。\n可以将神经元视作一个决策器，比如决定今天是否要带伞：\n输入：天气预报的温度、湿度、云量、风速等； 权重：不同特征对决策的影响程度； 计算(加权求和+激活)：综合所有信息后，决定是否带伞； 输出：最终决定(如 1=带伞，0=不带伞)。 局限性\n在前面的内容中可以发现，这一方法存在一些局限性：\n只支持二值输出：由于使用符号函数进行决策，神经元的输出为0或1； 无法处理非线性问题：sgn函数是线性的，它只会根据加权和是否大于0来判断； 不能自我学习：所有权重和阈值均需要人工设计。 单层感知机 (单层神经网络) $$ z_1 = g(a_1 * W_1 + a_2 * W_2 + a_3 * W_3) $$$$ z_2 = g(a_1 * W_4 + a_2 * W_5 + a_3 * W_6) $$$$ z_1 = g(a_1 * W_{1,1} + a_2 * W_{1,2} + a_3 * W_{1,3}) $$$$ z_2 = g(a_1 * W_{2,1} + a_2 * W_{2,2} + a_3 * W_{2,3}) $$$$ g(W*a) = z $$ 其中，$a=[a_1,a_2,a_3]^T$；$z=[z_1,z_2]^T$；W为2行3列的矩阵。\n感知机是如何训练的？\n$$ f(x) = sign(w^T·x+b) $$$$ sign(x) = \\begin{cases} +1, \u0026 x \\geq 0 \\\\ -1, \u0026 x \u003c 0 \\end{cases} $$感知机的几何解释：线性方程$w·x+b=0$对应于特征空间中的一个超平面$S$，其中$w$是超平面的法向量，$b$是超超平面的截距，这个超平面将特征空间划分为正负两部分：\n当$w^T·x_i+b\\geq0$时，$y_i=+1$； 当$w^T·x_i+b\u0026lt;0$时，$y_i=-1$； $$ y_i(w^T·x_i+b)\u003c0 $$$$ L(w, b) = - \\sum_{i \\in \\mathcal{M}} y_i (w^T· x_i + b) $$$$ \\nabla_w L = - \\sum_{i \\in \\mathcal{M}} y_i x_i $$$$ \\nabla_b L = - \\sum_{i \\in \\mathcal{M}} y_i $$$$ w = w - \\eta \\nabla_w L $$$$ b = b - \\eta \\nabla_b L $$$$ w = w + \\eta y_ix_i $$$$ b = b + \\eta y_i $$ 其中，$\\eta (0\u0026lt;\\eta\\leq 1)$为步长(学习率)。\n什么是梯度？\n$$ \\nabla_\\theta L = (\\frac{\\partial L}{\\partial \\theta_1}, \\frac{\\partial L}{\\partial \\theta_2}, ..., \\frac{\\partial L}{\\partial \\theta_n}) $$$$ \\theta \\leftarrow \\theta-\\eta\\nabla_\\theta L $$单层感知机代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import numpy as np class Perceptron: def __init__(self, input_dim, learning_rate=0.01, max_iter=1000): self.w = np.zeros(input_dim) self.b = 0 self.learning_rate = learning_rate self.max_iter = max_iter def activation(self, x): return np.sign(x) def predict(self, X): return np.array([self.activation(np.dot(self.w, x) + self.b) for x in X]) def fit(self, X, y): for _ in range(self.max_iter): errors = 0 for xi, yi in zip(X, y): pred = self.activation(np.dot(self.w, xi) + self.b) if pred != yi: self.w += self.learning_rate * yi * xi self.b += self.learning_rate * yi errors += 1 if errors == 0: break X = np.array([[0, 0], [0, 1], [1, 0], [1, 1]]) y = np.array([-1, -1, -1, 1]) # 训练 perceptron = Perceptron(input_dim=2, learning_rate=0.1, max_iter=100) perceptron.fit(X, y) # 测试 predictions = perceptron.predict(X) print(\u0026#34;预测结果：\u0026#34;, predictions) 局限性\n单层感知机只能处理可以通过一条直线(或超平面)分开的数据。非线性问题(如异或问题)就无法解决。\n多层感知机 (多层神经网络) 单层神经网络无法解决非线性问题(如异或问题)，但如果增加一个计算层，通过多次非线性映射，输入数据就可以被映射到更高维的特征空间，从而解决非线性可分问题。这个增加的计算层被称为隐藏层。增加的隐藏层由图中黄色的块表示：\n$$ h_1 = f(w_{1,1}*x_1 + w_{2,1}*x_2 + w_{3,1}*x_3 + b_1) $$$$ h_2 = f(w_{1,2}*x_1 + w_{2,2}*x_2 + w_{3,3}*x_3 + b_2) $$$$ y = v_1*h_1 + v_2*h_2 + b $$ 如果$f(·)$是线性的，增加了隐藏层的多层感知机本质上还是一个线性模型。而多层感知机的目的是让模型可以处理非线性问题，因此，这里的$f(·)$需要使用非线性函数。\n为什么使用非线性激活函数就可以增强模型能力？\n任意非线性函数都可以通过多个分段线性函数的组合来进行近似和表示。而在多层感知机中，激活函数(如ReLU、sigmoid等)帮助神经网络实现了这种分段线性变换，从而使得它可以拟合任意的非线性关系。\n然而，多层神经网络需要处理多个层次的权重和偏置，在每一层之间进行矩阵乘法和激活函数的非线性变换。随着网络深度的增加，计算复杂度呈指数级增长。\n1986年，Rumelhar和Hinton等人提出了反向传播(Backpropagation，BP)算法，解决了两层神经网络所需要的复杂计算量问题。反向传播的核心思想是通过计算损失函数相对于网络各个参数的梯度，来更新神经网络中的权重和偏置，从而使得网络在训练过程中最小化损失。\n链式法则\n对于$f(g(x))$，导数为：$\\frac{df}{dx} = \\frac{df}{dg}·\\frac{dg}{dx}$\n前向传播\n$$ h = \\sigma(z_1) $$$$ z_1 = w_1x+b_1 $$$$ y = z_2 $$$$ z_2 = w_2h+b_2 $$$$ L = \\frac{1}{2}(y-t)^2 $$反向传播\n$$ \\frac{\\alpha L}{\\alpha y} = y-t $$$$ \\frac{\\alpha L}{\\alpha w_2} = \\frac{\\alpha L}{\\alpha y}·\\frac{\\alpha y}{\\alpha w_2} = (y-t)·h^T $$$$ \\frac{\\alpha L}{\\alpha b_2} = \\frac{\\alpha L}{\\alpha y}·\\frac{\\alpha y}{\\alpha b_2} = y-t $$$$ \\frac{\\alpha L}{\\alpha h} = \\frac{\\alpha L}{\\alpha y}·\\frac{\\alpha y}{\\alpha h} = (y-t)·W_2^T $$$$ \\frac{\\alpha L}{\\alpha z_1} = \\frac{\\alpha L}{\\alpha h}·\\frac{\\alpha h}{\\alpha z_1} = \\frac{\\alpha L}{\\alpha h}·\\sigma'(z_1) $$$$ \\frac{\\alpha L}{\\alpha w_1} = \\frac{\\alpha L}{\\alpha z_1}·\\frac{\\alpha z_1}{\\alpha w_1} = \\frac{\\alpha L}{\\alpha z_1}·x^T $$$$ \\frac{\\alpha L}{\\alpha b_1} = \\frac{\\alpha L}{\\alpha z_1}·\\frac{\\alpha z_1}{\\alpha b_1} = \\frac{\\alpha L}{\\alpha z_1} $$$$ \\frac{\\alpha L}{\\alpha w_l} = \\frac{\\alpha L}{\\alpha z_l}·\\frac{\\alpha z_l}{\\alpha w_l} $$$$ \\frac{\\alpha L}{\\alpha b_l} = \\frac{\\alpha L}{\\alpha z_l}·\\frac{\\alpha z_l}{\\alpha b_l} $$ 其中，$w_l$、$b_l$是第$l$层的参数；$z_l$为第$l$层的输入(未激活)；$\\frac{\\alpha L}{\\alpha z_l}$是对第$l$层输入的梯度。\n多层感知机代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 import numpy as np class MLP: def __init__(self, input_size, hidden_size, output_size, learning_rate=0.1): self.input_size = input_size self.hidden_size = hidden_size self.output_size = output_size self.learning_rate = learning_rate np.random.seed(0) self.W1 = np.random.randn(input_size, hidden_size) self.b1 = np.zeros((1, hidden_size)) self.W2 = np.random.randn(hidden_size, output_size) self.b2 = np.zeros((1, output_size)) def sigmoid(self, x): return 1 / (1 + np.exp(-x)) def sigmoid_derivative(self, x): return x * (1 - x) def relu(self, x): return np.maximum(0, x) def relu_derivative(self, x): return (x \u0026gt; 0).astype(float) def forward(self, X): self.hidden_input = np.dot(X, self.W1) + self.b1 self.hidden_output = self.relu(self.hidden_input) self.final_input = np.dot(self.hidden_output, self.W2) + self.b2 self.final_output = self.sigmoid(self.final_input) return self.final_output def backward(self, X, y): error = y - self.final_output d_output = error * self.sigmoid_derivative(self.final_output) d_hidden = np.dot(d_output, self.W2.T) * self.relu_derivative(self.hidden_output) self.W2 += self.learning_rate * np.dot(self.hidden_output.T, d_output) self.b2 += self.learning_rate * np.sum(d_output, axis=0, keepdims=True) self.W1 += self.learning_rate * np.dot(X.T, d_hidden) self.b1 += self.learning_rate * np.sum(d_hidden, axis=0, keepdims=True) return np.mean(error ** 2) def train(self, X, y, epochs=100): for epoch in range(epochs): self.forward(X) loss = self.backward(X, y) if epoch % 100 == 0: print(f\u0026#34;Epoch {epoch}, Loss: {loss:.4f}\u0026#34;) def predict(self, X): return self.forward(X) # 训练 X = np.array([[0, 0], [0, 1], [1, 0], [1, 1]]) y = np.array([[0], [1], [1], [0]]) mlp = MLP(input_size=2, hidden_size=4, output_size=1) mlp.train(X, y) # 测试 print(\u0026#34;Final Predictions:\u0026#34;) print(mlp.predict(X)) 激活函数 在前面的内容中，我们多次提到了激活函数这个概念。激活函数在隐藏层和输出层增加了非线性操作，允许网络复制复杂的非线性行为，从而帮助网络学习数据中的复杂模式、提升表达能力。\n由于绝大多数神经网络都是借助某种形式的梯度下降进行优化，因此激活函数需要是可微分(或者至少是几乎完全可微分的)。\n下面简单介绍一些常用的激活函数。\n$$ \\sigma(x) = \\frac{1}{1+e^{-x}} $$$$ \\sigma'(x) = \\frac{e^{-x}}{(1+e^{-x})^2} = \\sigma(x)[1-\\sigma(x)] $$ 优点\n由图可以看出，Sigmoid函数的值域为[0,1]，输出范围有限，优化稳定，可以用作输出层，例如用于表示二分类的类别或者用于表示置信度。 该函数是连续可导的，可以提供非常平滑的梯度值，防止模型训练过程中出现突变的梯度(即避免跳跃的输出值)。 缺点\n导数的最大值只有0.25，网络越深，多个0.25相乘，梯度逐渐趋近于0，反向传播时其权重几乎得不到更新，从而使得模型变得难以训练，这就是梯度消失问题。 其输出不是以0为中心而是全大于0的(这会降低权重更新的效率)，下一层的神经元会得到上一层输出的全正信号作为输入，因此Sigmoid激活函数一般放在最后的输出层中使用。 指数运算耗时。 $$ f(x) = \\frac{e^{x_i}}{\\sum_{i=0}^{n}e^{x_i}} $$ 优点\nSoftmax将输出转化为概率，所有输出的值都在[0, 1]之间，并且所有类别的概率之和为1，适合多分类任务。 经过使用指数形式的Softmax函数能够将差距大的数值距离拉的更大。这有助于神经网络模型在进行多分类时区分不同类别的相对优先级。 缺点\n需要对所有类别的指数求和，这在类别数很大的时候会导致较高的计算开销。 在输出层，Softmax函数的梯度非常依赖于模型的输出。当某个类别的输出远大于其他类别时，梯度会变得非常小，导致梯度消失问题。 容易受到异常值的影响，尤其是在某些类别的得分非常大的时候。一个非常大的输入值可能会导致Softmax输出的概率几乎集中在一个类别上，从而影响其他类别的学习。 Sigmoid与Softmax的区别\nSigmoid适用于二分类问题 或多标签分类问题，输出为单一的概率值(通常为每个类别的独立概率)，而不是多个类别的相对概率分布。\nSoftmax适用于多分类问题，它将输出转换为概率分布，并且确保所有类别的概率之和为 1。\n$$ tanh(x) = \\frac{e^x-e^{-x}}{e^x+e^{-x}} $$$$ tanh'(x) = \\frac{4}{(e^x+e^{-x})^2} = 1-[tanh(x)]^2 $$ 优点\n值域为[-1, 1]，对称中心在原点，解决了Sigmoid激活函数输出不以0为中心的问题。 可以用于隐藏层。 缺点\n在两边与Sigmoid一样有梯度趋近于0的问题。 存在梯度消失问题。 同样需要进行指数计算。 $$ f(x) = \\begin{cases} x, \u0026 x \\geq 0 \\\\ 0, \u0026 x \u003c 0 \\end{cases} $$$$ f'(x) = \\begin{cases} 1, \u0026 x \\geq 0 \\\\ 0, \u0026 x \u003c 0 \\end{cases} $$ 优点\n正输入时是线性的，收敛速度快(梯度恒为1)，计算速度快。且当输入为正时，由于导数是1，能够完整传递梯度，不存在梯度饱和、梯度消失的问题。 无论是函数还是其导数都不包含复杂的数学运算，计算复杂度低，只需要一个阈值就可以得到激活值，收敛速度比sigmoid和tanh更快。 ReLU会使一部分神经元的输出为0，这样就造成了神经网络的稀疏性，并减少了参数的相互依存关系，缓解了过拟合问题的发生。 缺点\n输入为负时，输出为0，梯度也为0，相当于神经元直接死亡(Dead Neuron)，而且不会复活，这可能导致特征的学习不充分。 与Sigmoid一样，其输出不是以0为中心的。 $$ f(x) = \\begin{cases} x, \u0026 x \\geq 0 \\\\ \\lambda x, \u0026 x \u003c 0 \\end{cases}, \\lambda \\in (0, 1) $$$$ f'(x) = \\begin{cases} 1, \u0026 x \\geq 0 \\\\ \\lambda, \u0026 x \u003c 0 \\end{cases}, \\lambda \\in (0, 1) $$ 优点\n通过在负半轴添加一个小的正斜率，使得负轴的信息不会全部丢失，以此解决神经元死亡的问题。\n缺点\n超参数$\\lambda$需要人为设定，但不同任务可能需要不同的最佳$\\lambda$，增加了超参数调优的复杂度。 当输入值较大时，Leaky ReLU仍可能导致梯度爆炸，需要配合Batch Normalization或其他正则化方法。 在实际操作中，尚未完全证明Leaky ReLU总是比ReLU更好。 $$ f(x) = \\begin{cases} x, \u0026 x \\geq 0 \\\\ \\alpha x, \u0026 x \u003c 0 \\end{cases} $$$$ f'(x) = \\begin{cases} 1, \u0026 x \\geq 0 \\\\ \\alpha, \u0026 x \u003c 0 \\end{cases} $$参数α通常为0到1之间的数字，并且通常相对较小:\n如果$𝛼 = 0$，则$f(x)$变为ReLU。 如果$𝛼 \u0026gt; 0$，则$f(x)$变为Leaky ReLU。 如果$𝛼$是可学习的参数，则$f(x)$为PReLU。 优点\n与Leaky ReLU类似，PReLU在负值域也有一个相对较小的斜率，可以避免Dead ReLU问题。 公式与Leaky ReLu相似，但并不完全一样。$𝛼$可以是常数，或自适应调整的参数。也就是说，如果让$𝛼$自适应，那么PReLu会在反向传播时更新参数$𝛼$。因此在不同数据集上，PReLU通常比Leaky ReLU更稳定。 缺点\nPReLU让每个神经元都学习一个额外的参数$𝛼$，这会增加模型的自由度，导致模型在小数据集上可能过拟合。 在某些简单任务中，ReLU已经足够有效，而PReLU的额外参数反而可能带来不必要的复杂度。 $$ f(x) = \\begin{cases} x, \u0026 x \\geq 0 \\\\ \\alpha x, \u0026 x \u003c 0 \\end{cases} $$$$ f'(x) = \\begin{cases} 1, \u0026 x \\geq 0 \\\\ \\alpha, \u0026 x \u003c 0 \\end{cases} $$ 优点\n与Leaky ReLU类似，RReLU在负半轴保持非零梯度，避免ReLU的神经元死亡问题。 训练时随机选取$\\alpha$，可以一定程度上减少过拟合，提高模型的泛化能力。 缺点\n参数$𝛼$取值随机，训练过程中模型参数的更新方向可能会有所波动，在某些任务上可能会影响收敛速度。 在测试时使用固定的$𝛼$(取均值)，而训练时是随机的，可能导致模型表现略有偏差。 $$ f(x) = \\begin{cases} x, \u0026 x \\geq 0 \\\\ \\alpha (e^x-1), \u0026 x \u003c 0 \\end{cases} $$$$ f'(x) = \\begin{cases} 1, \u0026 x \\geq 0 \\\\ \\alpha e^x, \u0026 x \u003c 0 \\end{cases} $$ 优点\nELU在负值时是一个指数函数，具有软饱和特性，对噪声更鲁棒，抗干扰能力强；在较小的输入下会饱和至负值，从而减少前向传播的变异和信息。 右侧线性部分使ELU能够缓解梯度消失。 ELU的输出均值接近于0，收敛速度快。 缺点\n在输入为负时需要进行指数计算，计算稍复杂。 $\\alpha$参数需要额外调整。 $$ f(x) = \\lambda\\begin{cases} x, \u0026 x \u003e 0 \\\\ \\alpha (e^x-1), \u0026 x \\leq 0 \\end{cases} $$$$ f'(x) = \\begin{cases} \\lambda, \u0026 x \u003e 0 \\\\ \\lambda \\alpha e^x, \u0026 x \\leq 0 \\end{cases} $$ 优点\nSELU具有自归一化的特性，这使得网络的每一层的输出会在训练过程中保持均值为0，方差为1，从而减轻了梯度消失和梯度爆炸问题。让网络自动保持输入分布的一致性，避免额外的Batch Normalization或Layer Normalization操作保持输出层的稳定。 内部归一化比外部归一化更快，这使得网络收敛得更快。且每一层的激活函数输出不再依赖于外部约束，减少了对优化器的依赖。 负值范围通过指数函数保持非零梯度，防止了梯度消失。 缺点\nSELU本身已经具备了自归一化特性，它不适合与Batch Normalization结合使用。如果同时使用BN，可能会破坏其自归一化能力。 SELU的指数部分在负值区域导致输出非常小，可能会导致过度的稀疏性。类似神经元长时间“死亡”。 $$ f(x) = \\lambda\\begin{cases} x, \u0026 x \u003e 0 \\\\ \\alpha (e^\\frac{x}{\\alpha}-1), \u0026 x \\leq 0 \\end{cases} $$$$ f'(x) = \\begin{cases} 1, \u0026 x \u003e 0 \\\\ e^\\frac{x}{\\alpha}, \u0026 x \\leq 0 \\end{cases} $$ 优点\nCELU在负区间使用了平滑的指数函数，梯度更连续、平滑。 对负值区间的指数部分进行平滑处理，避免了激活值快速增大的问题，不容易引起梯度爆炸。 负值范围输出非零梯度，防止了梯度消失。 这种平滑的激活函数使得训练更稳定，有助于深度神经网络的收敛。 缺点\n在面对复杂的非线性问题时。过度平滑可能会限制网络学习到更复杂的特征表示，从而影响网络的表达能力。 与ELU一样具有自归一化特性，与BN不完全兼容。 CELU的表现依赖于超参数$\\alpha$，该参数控制了负区间的输出。 $$ GELU(x) = 0.5x(1+tanh(\\sqrt{\\frac{2}{\\pi}}(x+0.044715x^3))) $$ 优点\n当方差为无穷大，均值为0的时候，GeLU就等价于ReLU了。GELU可以当作为RELU的一种平滑策略。GELU是非线性输出，具有一定的连续性。 负值范围输出非零梯度，防止了梯度消失。 GELU利用高斯误差函数(误差函数与标准正态分布密切相关)，对输入进行概率化变换，这种特性有助于神经网络学习更加复杂和非线性的模式。 缺点\nGELU的优势主要体现在深度神经网络中，对于较浅的网络，ReLU等激活函数可能已经足够好。使用GELU可能无法提供显著的性能提升，反而由于计算开销的增加，可能会降低网络的训练和推理效率。\n$$ f(x) = x·\\sigma(\\beta x) $$$$ f'(x) = xf(\\beta x)(1-f(\\beta x)) + f(\\beta x) $$ 优点\n和ReLU一样，没有上边界，因此不会出现梯度饱和的现象(避免过拟合)。 有下边界，可以产生更强的正则化效果(x左半轴慢慢趋近0)。 连续可导，且在整个输入空间中具有平滑的过渡，使Swish能够更好地保持梯度信息，并且在训练时能更好地传播梯度，帮助深度神经网络更有效地学习复杂的特征。 自门控特性，即函数的输出由输入的本身和经过Sigmoid变换后的输入共同决定。这使得Swish在网络的每一层都能根据输入的特征来动态地调整激活函数的“门控”程度，从而更适应输入的不同情况。 缺点\nSwish的优势主要体现在深度神经网络中，特别是在处理更复杂的特征时。在一些浅层网络上，Swish可能不会比其他激活函数(如 ReLU或Sigmoid)带来显著的性能提升。 由于其涉及到Sigmoid函数的计算，Swish的计算效率不如ReLU，在推理时的延迟可能较高。 $$ SwiGLU(x) = Swish(x)·\\sigma (Wx+b) $$ 其中，$Swish(x)=x·\\sigma (x)$，即Swish激活函数；$\\sigma(Wx+b)$是Sigmoid门控函数，控制激活值的开关。\n优点\n结合了Swish和GLU的特性，具有非线性表示能力 和门控机制。 在深度神经网络中，能够加速训练收敛，并提高梯度流动和信息传播效率。 通过门控机制避免了梯度爆炸和梯度消失问题，增强了训练稳定性。 具有平滑的激活函数，能学习更加复杂的模式。 缺点\n计算开销相对较大，计算复杂性较高。 不适合浅层网络。 梯度消失和梯度爆炸 在前面激活函数的介绍中我们多次提到了梯度消失和梯度爆炸的概念，下面再对其概念和解决方法做一下总结。\n梯度消失\n当反向传播层数逐渐增多，由于每一层都对前一层梯度乘以了一个小数，因此随着反向传播，梯度逐层减小，导致靠近输入层的权重更新极慢甚至停止更新，网络难以学习到有效的特征。\n解决方案：\n选择合适的激活函数，如ReLU(大于0时导数为1)、Leaky ReLU(在ReLU能力上避免了神经元死亡问题)、ELU(保持ReLu有时的同时解决Dead ReLU问题)等。 采用ResNet残差连接，通过“跳跃连接”直接把输入传递给后续层，使得梯度可以绕过某些层，解决梯度消失问题，使得网络可以训练非常深。 适当的权重初始化：Xavier初始化/He初始化，防止梯度在传播过程中过大或过小。 使用Batch Normalization/Layer Normalization。 梯度爆炸\n随着误差反向传播，梯度值逐层增大，导致靠近输入层的权重更新过大，从而使模型训练变得不稳定，甚至梯度数值溢出(NaN)。其原因是初始权重过大，导致梯度不断放大\n解决方案：\n梯度裁剪，即设定一个剪切阈值，当梯度过大时，将其限制在一定范围。 采用L2正则化约束权重大小，防止梯度过大。 适当的权重初始化：Xavier初始化/He初始化，防止梯度在传播过程中过大或过小。 使用Batch Normalization/Layer Normalization。 正则化技术(防止过拟合) Batch Normalization和Layer Normalization 优化器 Reference [1] https://blog.csdn.net/illikang/article/details/82019945?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522b8ddfd309f99fabf168aaa1b10b4063a%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D\u0026request_id=b8ddfd309f99fabf168aaa1b10b4063a\u0026biz_id=0\u0026utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-82019945-null-null.142^v102^pc_search_result_base9\u0026utm_term=%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C\u0026spm=1018.2226.3001.4187\n[2] https://blog.csdn.net/seasonsyy/article/details/136124829?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522e47868d831ef55e9c4b37db9be731232%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D\u0026request_id=e47868d831ef55e9c4b37db9be731232\u0026biz_id=0\u0026utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-136124829-null-null.142^v102^pc_search_result_base9\u0026utm_term=%E6%84%9F%E7%9F%A5%E6%9C%BA%E8%AE%AD%E7%BB%83\u0026spm=1018.2226.3001.4187\n[3] https://blog.csdn.net/illikang/article/details/82019945?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522b8ddfd309f99fabf168aaa1b10b4063a%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D\u0026request_id=b8ddfd309f99fabf168aaa1b10b4063a\u0026biz_id=0\u0026utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-82019945-null-null.142%5Ev102%5Epc_search_result_base9\u0026utm_term=%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C\u0026spm=1018.2226.3001.4187https://blog.csdn.net/illikang/article/details/82019945?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522b8ddfd309f99fabf168aaa1b10b4063a%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D\u0026request_id=b8ddfd309f99fabf168aaa1b10b4063a\u0026biz_id=0\u0026utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-82019945-null-null.142%5Ev102%5Epc_search_result_base9\u0026utm_term=%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C\u0026spm=1018.2226.3001.4187\n[4] https://zhuanlan.zhihu.com/p/369328305\n[5] https://zhuanlan.zhihu.com/p/642537175\n[6] https://blog.csdn.net/caip12999203000/article/details/127067360?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522aa20995c1e0fe5de0e2fb06bae4373e4%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D\u0026request_id=aa20995c1e0fe5de0e2fb06bae4373e4\u0026biz_id=0\u0026utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-127067360-null-null.142^v102^pc_search_result_base9\u0026utm_term=%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0\u0026spm=1018.2226.3001.4187\n","date":"2025-03-30T15:21:57+08:00","image":"https://JLING-L.github.io/p/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%801-%E6%84%9F%E7%9F%A5%E6%9C%BA%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E6%AD%A3%E5%88%99%E5%8C%96bn%E5%92%8Cln%E4%BC%98%E5%8C%96%E5%99%A8/deep_neural_network_hu_547b519b3967cac4.png","permalink":"https://JLING-L.github.io/p/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%801-%E6%84%9F%E7%9F%A5%E6%9C%BA%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%E6%AD%A3%E5%88%99%E5%8C%96bn%E5%92%8Cln%E4%BC%98%E5%8C%96%E5%99%A8/","title":"深度学习基础1 | 感知机、激活函数、正则化、BN和LN、优化器"},{"content":"","date":"2025-03-30T13:10:43+08:00","permalink":"https://JLING-L.github.io/p/colpali_blog/","title":"ColPali_blog"},{"content":" 论文：https://arxiv.org/abs/2304.08085\n代码：https://github.com/BeyonderXX/InstructUIE\n之前的笔记中我们介绍了UIE(通用信息抽取1)和USM(通用信息抽取2)。我们先回顾一下这两篇工作：\nUIE\nUIE通过设计的结构提取语言SEL对异构IE结构进行统一建模，使用结构模式指令器SSI为不同IE任务生成目标结构，通过在多个数据集上预训练模型捕获通用IE能力。\nUIE将IE任务统一为seq2seq生成任务，输入为文本形式，输出为对应的结构化信息。\n局限性：由于不同任务的输出模式可能不同，UIE需要针对不同的下游任务进行单独的微调，以生成特定格式的输出。 USM\nUSM将IE任务解耦为结构化和概念化两个基本任务。通过TTL操作结构化信息，获取基本信息单元。通过LTL、TLL操作概念化信息，在label和基本信息单元间建立链接。\nUSM基于语义匹配机制，通过比对文本span与语义标签的相似性来完成IE任务。\n局限性：将IE转化为语义匹配任务，难以与生成式语言模型集成；需要对每个单词进行语义匹配，导致训练和推理时间显著增加。 LLM通过多任务训练和统一编码展现出强大的泛化能力，而有研究表明，LLM在IE任务上仍有显著的性能差距。\n那么，是否有办法激发LLM的潜在知识来完成IE任务？\nInstructUIE Task Schema 为了更好地转移和利用在预训练语言模型中学习到的知识，将IE任务重新表述为seq2seq形式，并微调LLM。如图所示，每个任务实例都用四个属性格式化：\n任务指令(Task Instruction)：提供详细的指导，说明如何从输入文本中提取相关信息，并生成所需的输出结构。具体内容包括要提取的信息类型、输出结构的格式以及提取过程中需要遵循的额外约束或规则。 选项(Options)：定义任务的输出标签约束，表示模型可以为给定输入生成的可能输出集。例如，在命名实体识别(NER)中，选项可能包括\u0026quot;person\u0026quot;、\u0026ldquo;organization\u0026rdquo;、\u0026ldquo;location\u0026quot;等实体标签；在关系提取(RE)中，选项可能代表可以提取的关系类型，如\u0026quot;works for\u0026rdquo;、\u0026ldquo;born in\u0026quot;等；在事件提取(EE)中，选项可能对应不同事件类型的标签，如\u0026quot;beginning\u0026rdquo;、\u0026ldquo;end\u0026quot;等。 文本(Text)：任务实例的输入句子，与任务指令和选项一起输入预训练的语言模型，使模型能够为给定任务生成所需的输出序列。 输出(Output)：将样本的原始标签转换为句子格式。对于NER，输出格式为\u0026quot;entity tag: entity span\u0026rdquo;；对于RE，输出格式为\u0026quot;relationship: head entity, tail entity\u0026quot;； 对于EE，输出格式为\u0026quot;event tag: trigger word, argument tag: argument span\u0026quot;； 如果输入中没有与提供选项匹配的结构信息，则输出\u0026quot;None\u0026quot;。 Auxiliary Tasks 辅助任务，与主任务一起训练。\nNER：引入了span extraction task和entity typing task。span extraction task旨在从输入句子中提取实体span，而entity typing task旨在识别实体的类型。 RE：引入了entity pair extraction task和relation classification task。entity pair extraction task旨在提取关系中涉及的实体对，而relation classification task旨在对实体对之间的关系类型进行分类。 EE：引入了trigger extraction task和argument extraction task。trigger extraction task旨在提取触发事件的触发词，而argument extraction task旨在提取相关的参数。 IE INSTRUCTIONS IE INSTRUCTIONS收集了32个公开可用的数据集，涵盖三种类型的IE任务：NER、RE和EE。除了新闻和维基数据等通用领域的来源之外，还包括来自科学、医疗保健、社交媒体和交通等各个领域的语料库，以确保数据集的多样性。\n数据处理步骤：\n统一不同数据集中语义相同但名称不同的标签的名称。 将带有下划线、缩写或特殊格式的标签转换为自然语言格式。例如，将标签\u0026quot;people person place of birth\u0026quot;重命名为\u0026quot;place of birth\u0026quot;。 将所有数据集转换为文本到文本格式，确保所有任务中输入输出对的一致表示。 数据集构成如图所示：\nExperiments backbone：FlanT5-11B\nSupervised Experiments Supervised学习设置：在训练期间为所有任务提供指令，模型在每个任务的标注数据上进行微调，使其能够学习特定任务的特征。为了平衡数据集，作者采用了抽样策略。即为每个数据集采样10,000个示例，少于10,000个样本的数据集使用所有示例。\nZero-shot Experiments Zero-shot学习设置：在训练期间仅为部分任务提供指令，模型在未见过的任务上进行评估，无需额外的微调。作者在18个NER数据集和6个RE数据集上训练了模型，并在7个NER数据集和2个RE数据集上进行测试(训练阶段删除了zero-shot实验需要测试的数据集)。\nps：详细的实验结果可以查看原文。\nConclusion 提出了UIE的一个End-to-End框架——InstructUIE，它利用自然语言指令来指导IE任务。 引入新的基准数据集IE INSTRUCTIONS。该基准由32个不同的信息提取数据集组成，这些数据集已统一为文本到文本格式，允许对各种IE任务进行一致和标准化的评估。 实验结果表明，InstructUIE在监督和zero-shot下实现了SOTA，使用单个多任务模型解决了多个任务。 ","date":"2024-11-04T13:31:44+08:00","image":"https://JLING-L.github.io/p/%E9%80%9A%E7%94%A8%E4%BF%A1%E6%81%AF%E6%8A%BD%E5%8F%963-instructuie-multi-task-instruction-tuning-for-unified-information-extraction/framework_hu_a7d88f2e718ff66c.jpg","permalink":"https://JLING-L.github.io/p/%E9%80%9A%E7%94%A8%E4%BF%A1%E6%81%AF%E6%8A%BD%E5%8F%963-instructuie-multi-task-instruction-tuning-for-unified-information-extraction/","title":"通用信息抽取3 | InstructUIE: Multi-task Instruction Tuning for Unified Information Extraction"},{"content":" 论文：https://arxiv.org/abs/2301.03282\nAccepted by AAAI2023\n上一篇我们介绍了UIE，它采用了文本-结构、seq2seq的生成方法。这一方法具有\u0026quot;黑盒\u0026quot;特性，信息片段(如实体、关系、关键词等)和模式(如输出结构)之间的关联是隐式的，这可能导致以下问题：\n由于模型在生成过程中不显式地展示哪些信息片段与模式相关联，因此难以判断模型学到了哪些知识。无法判断它是否真正理解了实体关系，还是仅仅是在模拟训练数据的表面模式。 由于信息片段和生成模式的关联是隐式的，在迁移到新的任务或模式时，模型是否能够正确应用已有知识变得难以预测。 Note：输入的信息被编码器编码成一组上下文向量，这些向量包含了输入的所有信息。但这些向量本身是高度抽象的，并没有显式地表示出输入中的特定信息片段(如重要的实体或关系)。而输出的每一步依赖于隐含的上下文向量和之前的输出，这种生成方式也没有显式地表现模型是如何将某些输入信息片段映射到具体的输出部分的。由于这些关联是隐含的，很难解释模型在生成过程中是如何决策的。例如，模型可能在输出中提到了某个关键实体，但难以追踪它是根据哪个输入信息片段得出的。\n因此，作者认为，为了确保有效、稳健和可解释的迁移能力，显式建模和学习可迁移的知识是必要的。\nUnified Semantic Matching via Directed Token Linking Schema-Text Joint Embedding 为了让模型理解标签模式(schema)和文本之间的关联(同时捕捉标签和文本之间的语义关系)，USM对提取模式(schema)和文本token进行共同编码，从而生成它们的联合上下文嵌入：\n提取模式词序列化：USM将提取模式(schema)表示为一个词序列。例如，如果提取模式是\u0026quot;person\u0026quot;和\u0026quot;location\u0026quot;这样的标签，USM会将这些标签转换为词序列形式，即{$l_1,l_2,\u0026hellip;,l_{|l|}$}。(类似文本token) 拼接schema和文本：USM将词序列化后的schema sequence与文本token{$t_1,t_2,\u0026hellip;,t_{|t|}$}进行拼接，一起作为模型的输入。 Transformer编码器：拼接后的词序列和文本通过一个Transformer编码器进行处理，计算出联合的上下文嵌入H，表示为[$h_1,h_2,\u0026hellip;,h_{|l|+|t|}$]。 Mask矩阵：M是一个Mask矩阵，用来决定哪些标签或文本token可以互相\u0026quot;看到\u0026quot;(self-attention)，从而捕捉它们之间的交互关系。 $$ H = Encoder(l_1,l_2,...,l_{|l|},t_1,t_2,...,t_{|t|},M) $$Token Linking Operations 要实现UIE，还是要对不同IE任务进行统一建模。\n类似UIE的定位(Spotting)和关联(Associating)，作者将IE任务解耦为两个操作：\n结构化(Structuring)：从文本中抽取出与标签无关的基本子结构。例如，实体抽取\u0026quot;Monet\u0026quot;；事件触发词\u0026quot;born in\u0026quot;；关系实体对(\u0026ldquo;Monet\u0026rdquo;，\u0026ldquo;Paris\u0026rdquo;)；事件论元(\u0026ldquo;born in\u0026rdquo;，\u0026ldquo;Paris\u0026rdquo;)。 概念化(Conceptualizing)：在概念化阶段将这些具体子结构与语义标签相连接。例如：\u0026ldquo;Monet\u0026quot;可以标记为\u0026quot;person\u0026rdquo;。 其中，结构化通过Token-Token Linking (TTL)操作实现，概念化通过Label-Token Linking (LTL)和Token-Label Linking (TLL)操作实现。\nToken-Token Linking for Structuring (TTL) 前面我们提到，结构化的目标是要提取出文本中的基本信息单元(如实体、关系、触发词等)。这些基本信息单元是一组连续的token序列，我们需要知道单个信息单元是从哪里开始、又从哪里结束。\n而部分IE任务所需的结构可能包括不止一个信息单元，例如{\u0026ldquo;Monet\u0026rdquo;, birth place, \u0026ldquo;Paris\u0026rdquo;}就是一个三元组的形式，此时，我们则需要找到Subject-Object对。\n作者设计了TTL操作，从两个方面对输入文本中所有有效的子结构进行构造：\nUtterance(文本)：指输入文本中的连续token序列，例如实体(如\u0026quot;Monet\u0026quot;)或事件触发词(如\u0026quot;born in\u0026quot;)。\n如图所示，其实就是将头和尾链接(H2T)。例如，为了提取span\u0026quot;Monet\u0026quot;和\u0026quot;born in\u0026quot;作为有效的子结构，USM利用H2T将\u0026quot;Monet\u0026quot;链接到自身来提取\u0026quot;Monet\u0026quot;，并将\u0026quot;born\u0026quot;链接到\u0026quot;in\u0026quot;以提取\u0026quot;born in\u0026quot;。 Association Pair(文本对)：从文本中提取的基本关联对单元，例如关系的Subject-Object对(如\u0026quot;Monet\u0026quot;和\u0026quot;Paris\u0026quot;)或事件触发词-参数对(如\u0026quot;born in\u0026quot;和\u0026quot;Paris\u0026quot;)。\n如图所示，链接关联对是将头与头链接(H2H)、尾与尾链接(T2T)。例如，要提取Subject-Object对\u0026quot;Monet\u0026quot;和\u0026quot;Paris\u0026quot;，USM通过H2H将\u0026quot;Monet\u0026quot;和\u0026quot;Paris\u0026quot;链接起来，同时也通过T2T链接这两个token。 $$ s_{TTL}(t_i,t_j) = FFNN_{TTL}^l(h_t^i)^TR_{j-i}FFNN_{TTL}^r(h_t^j) $$ 其中，FFNN为前馈神经网络层，用于处理token的嵌入信息。$R_{j-i}$是一个旋转位置嵌入(用于编码token之间的相对位置关系)。通过这种方式，模型可以捕捉到token之间的相对位置关系。\nLabel-Token Linking for Utterance Conceptualizing (LTL) 结构化是从Utterance和Association Pair两个方面来进行处理的，概念化也是如此。首先考虑Utterance的概念化，包括两种类型：\nType of Mention：将标签类型直接分配给span。例如，将实体\u0026quot;Monet\u0026quot;标记为类型\u0026quot;person\u0026quot;，\u0026ldquo;France\u0026quot;标记为类型\u0026quot;country\u0026rdquo;。 Predicate of Object：将关系标签分配给Association Pair中的Object。例如，\u0026ldquo;Paris\u0026quot;的关系类型\u0026quot;birth place\u0026rdquo;，事件参数类型\u0026quot;capital\u0026quot;。 用label-to-head(L2H)和label-to-tail(L2T)链接操作来为每个子结构分配标签(其实也是头对头、尾对尾，只是不是将信息单元进行链接了，而是将标签与信息单元进行链接)。链接分数的计算公式如下： $$ s_{LTL}(l_i,t_j) = FFNN_{LTL}^{label}(h_i^l)^TR_{j-i}FFNN_{LTL}^{Text}(h_j^t) $$ Token-Label Linking for Pairing Conceptualizing (TLL) $$ s_{TTL}(t_i,l_j) = FFNN_{TLL}^{text}(h_i^l)^TR_{j-i}FFNN_{TLL}^{label}(h_j^t) $$Schema-Text Joint Embedding 通过schema-constraint解码，如图所示：\n通过TTL操作提取的内容：例如，{\u0026ldquo;Monet\u0026rdquo;, \u0026ldquo;Paris\u0026rdquo;, \u0026ldquo;France\u0026rdquo;, (\u0026ldquo;Monet\u0026rdquo;, \u0026ldquo;Pairs\u0026rdquo;), (\u0026ldquo;France\u0026rdquo;, \u0026ldquo;Pairs\u0026rdquo;)}，抽取得到\u0026quot;Monet\u0026quot;和\u0026quot;Paris\u0026quot;，以及Subject-Object对(\u0026ldquo;Monet\u0026rdquo;, \u0026ldquo;Paris\u0026rdquo;)和(\u0026ldquo;France\u0026rdquo;, \u0026ldquo;Paris\u0026rdquo;)。 通过LTL操作提取的内容：例如，{(person, \u0026ldquo;Monet\u0026rdquo;), (country, \u0026ldquo;France\u0026rdquo;), (birth place, \u0026ldquo;Paris\u0026rdquo;), (capital, \u0026ldquo;Paris\u0026rdquo;)}，每个label(如person、country)都与相应的Object(如\u0026quot;Monet\u0026quot;、\u0026ldquo;France\u0026rdquo;)相关联。 通过TLL操作提取的内容：例如，(\u0026ldquo;Monet\u0026rdquo;, birth place), (\u0026ldquo;France\u0026rdquo;, capital)，将Subject与其相应的关系label(如birth place、capital)联系起来。 基于获得的label-token间的链接(例如\u0026quot;Monet\u0026quot;与\u0026quot;birth place\u0026quot;以及\u0026quot;France\u0026quot;与\u0026quot;capital\u0026quot;)，USM能够一致地生成完整的结构，例如：(\u0026ldquo;Monet\u0026rdquo;, birth place, \u0026ldquo;Paris\u0026rdquo;)和(\u0026ldquo;France\u0026rdquo;, capital, \u0026ldquo;Paris\u0026rdquo;)。 这些解码步骤之间是独立的，这意味着提取操作是完全非自回归的(non-autoregressive)，这使得解码过程可以并行进行。\nLearning from Heterogeneous Supervision USM使用了标签的词序列化表示(verbalized label representation)和统一的token链接机制，不论资源的来源或类型如何，USM将它们统一表示为\u0026lt;text, token pairs\u0026gt;进行预训练。\nPre-training 异构监督资源(来源不同、类型多样的训练数据)包括任务注释信号(例如，IE数据集)、远程信号(例如，远程监督数据集)和间接信号(例如，QA数据集)三种不同类型：\n$D_{task}$(任务标注数据集)\n其中每个实例都有一个用于信息提取的标准注释。本文使用在信息提取领域广泛使用的Ontonotes作为标准注释，它包含18种实体类型。 任务标注数据集用于帮助模型学习任务特定的结构化和概念化能力。即通过这些标注数据，模型可以学习如何准确地从文本中提取特定类型的实体和关系。 $D_{distant}$(远程监督数据集)\n远程监督数据集是通过将文本与知识库对齐来生成的标注数据。本文使用NYT和Rebel作为远程监督数据集，这些数据集分别是通过将文本与Freebase和Wikidata对齐而获得。由于Rebel数据集的标签模式过长，不适合直接与输入文本拼接并输入到预训练的Transformer编码器中。因此，本文采样了负标签(与输入文本的实际内容没有对应关系的标签)模式构建meta schema，简化预训练时的标签模式。 远程监督数据为模型提供大规模的训练数据，帮助模型学习广泛的结构和概念化能力。 $D_{indirect}$(间接监督数据集)\n间接监督数据集来自与信息抽取相关的其他NLP任务，主要是阅读理解数据集。本文使用MRQA中的阅读理解数据集，如HotpotQA、Natural Questions、NewsQA、SQuAD、TriviaQA等。 间接监督数据集通过多样化的问题表达，提供了比$D_{task}$和$D_{distant}$更多样化的标签语义信息，有助于模型学习更丰富的概念化能力(增强泛化能力)。对于每个(question，context，answer)实例，问题作为label schema，context作为输入文本，answer作为mention。 Learning function $$ L = \\sum_{m \\in \\mathcal{M}} log \\left(1+\\sum_{(i, j) \\in m^{+}} e^{-s_{m}(i, j)}\\right) +\\log \\left(1+\\sum_{(i, j) \\in m^{-}} e^{s_{m}(i, j)}\\right) $$ 损失函数由两部分组成：\n针对已链接对$m^+$的损失，利用链接评分$s_m (i,j)$来计算概率，增加与正样本的联系。 针对未链接对$m^-$的损失，同样基于链接评分，但通过对未链接的对进行惩罚，降低其影响。 Experiments 对比USM和其他SOTA模型在4个任务的13个数据集上的性能。AVE-unify表示非重叠数据集的平均性能，AVE-total表示所有数据集的平均性能。USM实现了SOTA，在不使用预训练模型的情况下，用RoBERTa初始化的USM框架也表现出了较好的效果。\n在不同领域的9个数据集上进行zero-shot实验。即使从实体类型有限的$D_{task}$中学习，USM在电影、文学和音乐领域也表现出良好的迁移性能。$D_{distant}$和$D_{indirect}$在预训练过程中有重要作用。\nUSM(356M)以较小的模型大小优于强zero-shot基线GPT-3(175B)和DEEPSTRUCTURE(10B)。\n(详细的实验结果和分析可以查看原文)\nConclusion 提出了一个统一的语义匹配框架——USM。 UIE方法未能显式地展示信息片段与模式的关联、知识迁移效果难以预测 ——\u0026gt; USM通过结构化和概念化显式地建立了信息片段与标签之间的关联\n(例如，当迁移到新任务时，USM不需要重新学习基本的信息抽取能力，而是只需要在新领域中重新定义或调整概念化标签。这种显式关联使得知识的迁移更加系统化，减少了模型在新任务中的不确定性) USM在监督实验下达到了最先进的性能，在zero/few shot设置下表现出很强的泛化能力。 References [1] https://blog.csdn.net/qq_27590277/article/details/128699655?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522A7AAA045-C8D2-470D-8CB4-6FB0D7220C7D%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D\u0026request_id=A7AAA045-C8D2-470D-8CB4-6FB0D7220C7D\u0026biz_id=0\u0026utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-128699655-null-null.142^v100^pc_search_result_base1\u0026utm_term=Universal%20Information%20Extraction%20as%20Unified%20Semantic%20Matching\u0026spm=1018.2226.3001.4187\n[2] https://adaning.github.io/posts/11838.html\n","date":"2024-11-03T09:27:34+08:00","image":"https://JLING-L.github.io/p/%E9%80%9A%E7%94%A8%E4%BF%A1%E6%81%AF%E6%8A%BD%E5%8F%962-universal-information-extraction-as-unified-semantic-matching/cover_hu_dc3ad30122798b76.jpg","permalink":"https://JLING-L.github.io/p/%E9%80%9A%E7%94%A8%E4%BF%A1%E6%81%AF%E6%8A%BD%E5%8F%962-universal-information-extraction-as-unified-semantic-matching/","title":"通用信息抽取2 | Universal Information Extraction as Unified Semantic Matching"},{"content":" 论文：https://arxiv.org/abs/2203.12277\n代码：https://github.com/universal-ie/UIE\nAccepted to the main conference of ACL2022\n什么是信息抽取？\n我们首先简单介绍一下信息抽取，有了解的可以直接跳过。\n信息抽取(Information Extraction, IE)是自然语言处理(NLP)领域的一个任务，旨在从非结构化的文本数据中自动识别并提取结构化的信息，例如提取文本中的关键实体、关系或事件等。主要关注三个任务：\n例：Steve became CEO of Apple in 1997.\n命名实体识别(Named Entity Recognition, NER)\nNER任务的目标是识别文本中的实体(如人名、地点、组织等)并分类。对于上面给出的例句，识别实体\u0026quot;Steve\u0026quot;，类型标注为\u0026quot;person\u0026quot;；识别实体\u0026quot;Apple\u0026quot;，类型标注为\u0026quot;organization\u0026quot;；识别实体\u0026quot;1997\u0026quot;，类型标注为\u0026quot;time\u0026quot;。 关系抽取(Relation Extraction)\nRE任务的目标是识别文本中的实体关系，明确它们之间的联系。对于上面给出的例句，头实体\u0026quot;Steve\u0026quot;，尾实体\u0026quot;Apple\u0026quot;，他们之间的关系为\u0026quot;work-for\u0026quot;。 事件抽取(Event Extraction)\nEE任务的目标是识别文本中发生的事件，并提取出事件的参与实体、时间、地点等信息(事件参数)。对于上面给出的例句，识别触发词\u0026quot;became\u0026quot;，类型标注为\u0026quot;start-position\u0026quot;。事件下对应的三个论元\u0026quot;Steve\u0026quot;，\u0026ldquo;Apple\u0026rdquo;，\u0026ldquo;1997\u0026quot;分别扮演\u0026quot;employee\u0026rdquo;，\u0026ldquo;employer\u0026rdquo;，\u0026ldquo;time\u0026quot;的事件角色。 可以看出，对于不同的IE任务，随着任务目标的变化，需要抽取出的信息的结构也各有不同，例如在NER中要抽取出的是句子中的单词或短语，在RE任务中又需要判断两个实体间的关系。\n因此要完成不同的任务，就需要定义不同的抽取模式(即信息抽取时需要遵循的结构化规则或框架)。\n但可以观察到，这几个任务之间其实是有共通之处的，比如RE，就可以看作是NER任务的进一步扩展。\n是否有办法对这三个任务进行统一建模？\n下面我们来看一下UIE这篇文章。\nUnified Structure Generation for Universal Information Extraction IE受到其不同目标、异构结构和特定需求模式的影响，此前大多数IE方法都是为不同的任务设计不同的模型，这存在几个问题：\n为大量的IE任务/设置/场景开发专用架构非常复杂(比如单独设计一个模型，专门处理RE任务；单独设计一个模型，专门处理EE任务，听起来就很麻烦)。 学习孤立的模型严重限制了相关任务和设置之间的知识共享(比如RE任务，NER任务中实体已经抽取好了、类别也标注好了，为什么不能直接用呢)。 构建专门用于不同IE任务的数据集和知识源既昂贵又耗时(不同任务的数据集的知识是不是可以共享呢)。 作者认为，所有IE任务都可以建模为文本到结构(text-to-structure)的转换。\nStructured Extraction Language for Uniform Structure Encoding (SEL) 首先，要将不同的IE结构编码成统一的表示，这样就可以在同一个文本-结构的生成框架中对各种IE任务进行统一建模。具体而言，作者将这一转换过程拆分为了两个子操作：\n例：Steve works for Apple.\n定位(Spotting)：在文本中找到特定语义类型的span，将文本中的特定span根据预先定义的语义类型进行标注。例：\u0026ldquo;Steve\u0026quot;被标注为\u0026quot;Person\u0026rdquo;。 关联(Associating)：对已经定位的span进行关联(例如标记实体对之间的关系)。例：将\u0026quot;Steve\u0026quot;标记为Arg1，\u0026ldquo;Apple\u0026quot;标记为Arg2(类似将\u0026quot;Steve\u0026quot;视为头实体，\u0026ldquo;Apple\u0026quot;视为尾实体)。关联Arg1和Arg2，即判断这两个实体之间的关系，我们将关系标注为\u0026quot;Work-for\u0026rdquo;。 作者使用Spot Name和Asso Name分别表示Spotting和Associating操作。Info Span则表示Spot Name和Asso Name所标记的实际文本信息。\n我们来看作者给出的一个具体示例。\n例：对于文本输入\u0026quot;Steve became CEO of Apple in 1997.\u0026quot;，通过SEL生成的结构：\nRE(蓝色)：头实体\u0026quot;Steve\u0026rdquo;(Info Span)，类型标注为\u0026quot;person\u0026rdquo;(Spot Name)；尾实体\u0026quot;Apple\u0026quot; (Info Span)，类型标注为\u0026quot;organization\u0026quot;(Spot Name)；关系\u0026quot;work-for\u0026quot;(Asso Name)。 EE(红色)：触发词\u0026quot;became\u0026quot;(Info Span)，类型标注为\u0026quot;start-position\u0026quot;(Spot Name)。事件下对应的三个论元\u0026quot;Steve\u0026quot; (Info Span)，\u0026ldquo;Apple\u0026rdquo; (Info Span)，\u0026ldquo;1997\u0026rdquo; (Info Span)分别扮演\u0026quot;employee\u0026quot;(Spot Name)，\u0026ldquo;employer\u0026rdquo;(Spot Name)，\u0026ldquo;time\u0026rdquo;(Spot Name)的事件角色。 NER(黑色)：实体\u0026quot;Steve\u0026quot;(Info Span)，类型标注为\u0026quot;person\u0026quot;(Spot Name)；实体\u0026quot;Apple\u0026quot; (Info Span)，类型标注为\u0026quot;organization\u0026quot;(Spot Name)；实体\u0026quot;1997\u0026quot; (Info Span)，类型标注为\u0026quot;time\u0026quot;(Spot Name)。 这样一来，无论对二元关系，还是N元论元结构，都可以用SEL语法表示。\nStructural Schema Instructor for Controllable IE Structure Generation (SSI) 虽然三个IE任务都可以通过SEL统一表示结构，但模型还不知道什么时候该做什么。\n作者设计了特殊符号[spot], [asso]和[text]，分别添加到每个Spot Name、Asso Name和输入文本序列之前，来提示模型要提取哪些信息。\n具体的例子如图所示，类似于给一个表格让模型去填写表格内容。\n但当需要提取出的信息较多、句子结构比较复杂的情况下，输入序列会变得非常长：\nStructure Generation with UIE 简单来说，UIE的输入是SSI+Text的形式，输出是用SEL语法表示的结构。UIE整体可以看作是Encoder-Decoder架构的模型：\nEncoder $$ H = Encoder(s_1, s_2, s_{|s|}, x_1, ..., x_{|x|}) $$Decoder $$ y_i, h_i^d = Decoder([H; h_1^d, ..., h_{i-1}^d]) $$ 当解码器生成特殊的结束符号\u0026lt;eos\u0026gt;时，解码过程完成。\n作者认为，文本-结构的生成范式将标签视为自然语言标记，这一方法可以有效地转移来自BART、T5等预训练语言模型的知识，相关任务可以很容易地共享知识，因为它们的标签具有相似的语义(例如，location和place)，并共享共同的标签-文本关联(例如，不同事件类型的受害者)。\nPre-training for UIE 预训练数据集 包括结构化(例如，知识库)、非结构化(例如，原始文本)和并行(例如，维基百科-维基数据链接)数据：\n$D_{record}$(结构)：$D_{record}$是一个结构数据集，每个实例是一个结构化记录$y$。该数据集从ConceptNet(一个常识知识库)和Wikidata中收集结构化记录。$D_{record}$用于预训练UIE的结构解码能力，帮助模型在理解结构化记录后，能够从这些记录生成有效的输出。 $D_{text}$(文本)：$D_{text}$是一个非结构化文本数据集，包含英语维基百科中的所有纯文本。$D_{text}$用于预训练UIE的语义编码能力。通过对大规模的非结构化文本进行训练，模型能够更好地理解自然语言的语义、上下文和结构特征。 $D_{pair}$(文本+结构)：$D_{pair}$是文本-结构的并行数据集，每个实例由一对$(token序列x，结构化记录y)$组成。Dpair用于预训练UIE的文本到结构转换能力，使模型能够理解和处理文本与其对应结构之间的关系。 预训练任务 使用三个序列生成任务来预训练UIE：\nText-to-Structure Pre-training using $D_pair$：$p(y|x,s_meta)$表示在给定文本和模式的条件下生成结构记录$y$的概率。 $$ {L}_{\\text {Pair}}=\\sum_{(x, y) \\in \\mathcal{D}_{\\text {pair}}}-\\log p\\left(y \\mid x, s_{\\text {meta}} ; \\theta_{e}, \\theta_{d}\\right) $$ Structure Generation Pre-training with $D_record$：在给定之前生成的token的情况下，预测当前token $y_i$的负对数似然。 $$ {L}_{\\text {Record}}=\\sum_{y \\in \\mathcal{D}_{\\text {record}}}-\\log p\\left(y_i \\mid y_{\u003c i}; \\theta_{d}\\right) $$ Retrofitting Semantic Representation using $D_text$：给定被Mask的源文本，让模型还原被Mask的部分。 $$ {L}_{\\text {Text}}=\\sum_{x \\in \\mathcal{D}_{\\text {text}}}-\\log p\\left(x^{\\prime \\prime} \\mid x^{\\prime} ; \\theta_{e}, \\theta_{d}\\right) $$ $$ {L}={L}_{\\text {Pair}} + {L}_{\\text {Record}} + {L}_{\\text {Text}} $$Fine-tuning for UIE $$ {L}_{FT}=\\sum_{(s, x, y) \\in \\mathcal{D}_{\\text {Task}}}-\\log p\\left(y \\mid x, s; \\theta_{e}, \\theta_{d}\\right) $$ 为了缓解暴露偏差，在解码过程中，作者还设计了一种拒绝机制。给定实例$(s, x, y)$，使用SEL对$y$进行编码，随机加入$[NULL]$噪声。具体示例如图所示：\n句子中没有facility实体，在模型学习时随机注入\u0026quot;(facility：[NULL])\u0026ldquo;的噪声。通过这种方式，UIE可以通过生成[NULL]来有效地学习拒绝误导生成。\nExperiment 可以看到，UIE在多个任务上SOTA。\nps：其他的实验结果具体可以看原文，在这里就不详细说明了。\nConclusion 提出了一个统一的文本到结构生成框架——UIE(T5+结构化生成)，它可以通用地建模不同的IE任务，自适应地生成有针对性的结构，并从不同的知识源中学习通用的IE能力：\n多样化的目标结构 \u0026mdash;\u0026gt; SEL统一编码异构抽取结构 需求特定的抽取模式 \u0026mdash;\u0026gt; 基于模式的提示机制SSI 不同任务之间知识难以共享 \u0026mdash;\u0026gt; 在包含多个任务的数据集上预训练模型 ","date":"2024-10-30T16:37:14+08:00","image":"https://JLING-L.github.io/p/%E9%80%9A%E7%94%A8%E4%BF%A1%E6%81%AF%E6%8A%BD%E5%8F%961-unified-structure-generation-for-universal-information-extraction/uie_framwork_hu_3579f02a65c7dc48.jpg","permalink":"https://JLING-L.github.io/p/%E9%80%9A%E7%94%A8%E4%BF%A1%E6%81%AF%E6%8A%BD%E5%8F%961-unified-structure-generation-for-universal-information-extraction/","title":"通用信息抽取1 | Unified Structure Generation for Universal Information Extraction"}]