[{"content":" 论文：https://arxiv.org/abs/2304.08085\n代码：https://github.com/BeyonderXX/InstructUIE\n之前的笔记中我们介绍了UIE(通用信息抽取1)和USM(通用信息抽取2)。我们先回顾一下这两篇工作：\nUIE\nUIE通过设计的结构提取语言SEL对异构IE结构进行统一建模，使用结构模式指令器SSI为不同IE任务生成目标结构，通过在多个数据集上预训练模型捕获通用IE能力。\nUIE将IE任务统一为seq2seq生成任务，输入为文本形式，输出为对应的结构化信息。\n局限性：由于不同任务的输出模式可能不同，UIE需要针对不同的下游任务进行单独的微调，以生成特定格式的输出。 USM\nUSM将IE任务解耦为结构化和概念化两个基本任务。通过TTL操作结构化信息，获取基本信息单元。通过LTL、TLL操作概念化信息，在label和基本信息单元间建立链接。\nUSM基于语义匹配机制，通过比对文本span与语义标签的相似性来完成IE任务。\n局限性：将IE转化为语义匹配任务，难以与生成式语言模型集成；需要对每个单词进行语义匹配，导致训练和推理时间显著增加。 LLM通过多任务训练和统一编码展现出强大的泛化能力，而有研究表明，LLM在IE任务上仍有显著的性能差距。\n那么，是否有办法激发LLM的潜在知识来完成IE任务？\nInstructUIE Task Schema 为了更好地转移和利用在预训练语言模型中学习到的知识，将IE任务重新表述为seq2seq形式，并微调LLM。如图所示，每个任务实例都用四个属性格式化：\n任务指令(Task Instruction)：提供详细的指导，说明如何从输入文本中提取相关信息，并生成所需的输出结构。具体内容包括要提取的信息类型、输出结构的格式以及提取过程中需要遵循的额外约束或规则。 选项(Options)：定义任务的输出标签约束，表示模型可以为给定输入生成的可能输出集。例如，在命名实体识别(NER)中，选项可能包括\u0026quot;person\u0026quot;、\u0026ldquo;organization\u0026rdquo;、\u0026ldquo;location\u0026quot;等实体标签；在关系提取(RE)中，选项可能代表可以提取的关系类型，如\u0026quot;works for\u0026rdquo;、\u0026ldquo;born in\u0026quot;等；在事件提取(EE)中，选项可能对应不同事件类型的标签，如\u0026quot;beginning\u0026rdquo;、\u0026ldquo;end\u0026quot;等。 文本(Text)：任务实例的输入句子，与任务指令和选项一起输入预训练的语言模型，使模型能够为给定任务生成所需的输出序列。 输出(Output)：将样本的原始标签转换为句子格式。对于NER，输出格式为\u0026quot;entity tag: entity span\u0026rdquo;；对于RE，输出格式为\u0026quot;relationship: head entity, tail entity\u0026quot;； 对于EE，输出格式为\u0026quot;event tag: trigger word, argument tag: argument span\u0026quot;； 如果输入中没有与提供选项匹配的结构信息，则输出\u0026quot;None\u0026quot;。 Auxiliary Tasks 辅助任务，与主任务一起训练。\nNER：引入了span extraction task和entity typing task。span extraction task旨在从输入句子中提取实体span，而entity typing task旨在识别实体的类型。 RE：引入了entity pair extraction task和relation classification task。entity pair extraction task旨在提取关系中涉及的实体对，而relation classification task旨在对实体对之间的关系类型进行分类。 EE：引入了trigger extraction task和argument extraction task。trigger extraction task旨在提取触发事件的触发词，而argument extraction task旨在提取相关的参数。 IE INSTRUCTIONS IE INSTRUCTIONS收集了32个公开可用的数据集，涵盖三种类型的IE任务：NER、RE和EE。除了新闻和维基数据等通用领域的来源之外，还包括来自科学、医疗保健、社交媒体和交通等各个领域的语料库，以确保数据集的多样性。\n数据处理步骤：\n统一不同数据集中语义相同但名称不同的标签的名称。 将带有下划线、缩写或特殊格式的标签转换为自然语言格式。例如，将标签\u0026quot;people person place of birth\u0026quot;重命名为\u0026quot;place of birth\u0026quot;。 将所有数据集转换为文本到文本格式，确保所有任务中输入输出对的一致表示。 数据集构成如图所示：\nExperiments backbone：FlanT5-11B\nSupervised Experiments Supervised学习设置：在训练期间为所有任务提供指令，模型在每个任务的标注数据上进行微调，使其能够学习特定任务的特征。为了平衡数据集，作者采用了抽样策略。即为每个数据集采样10,000个示例，少于10,000个样本的数据集使用所有示例。\nZero-shot Experiments Zero-shot学习设置：在训练期间仅为部分任务提供指令，模型在未见过的任务上进行评估，无需额外的微调。作者在18个NER数据集和6个RE数据集上训练了模型，并在7个NER数据集和2个RE数据集上进行测试(训练阶段删除了zero-shot实验需要测试的数据集)。\nps：详细的实验结果可以查看原文。\nConclusion 提出了UIE的一个End-to-End框架——InstructUIE，它利用自然语言指令来指导IE任务。 引入新的基准数据集IE INSTRUCTIONS。该基准由32个不同的信息提取数据集组成，这些数据集已统一为文本到文本格式，允许对各种IE任务进行一致和标准化的评估。 实验结果表明，InstructUIE在监督和zero-shot下实现了SOTA，使用单个多任务模型解决了多个任务。 ","date":"2024-11-04T13:31:44+08:00","image":"https://JLING-L.github.io/p/%E9%80%9A%E7%94%A8%E4%BF%A1%E6%81%AF%E6%8A%BD%E5%8F%963-instructuie-multi-task-instruction-tuning-for-unified-information-extraction/framework_hu15262791796647838948.jpg","permalink":"https://JLING-L.github.io/p/%E9%80%9A%E7%94%A8%E4%BF%A1%E6%81%AF%E6%8A%BD%E5%8F%963-instructuie-multi-task-instruction-tuning-for-unified-information-extraction/","title":"通用信息抽取3 | InstructUIE: Multi-task Instruction Tuning for Unified Information Extraction"},{"content":" 论文：https://arxiv.org/abs/2301.03282\nAccepted by AAAI2023\n上一篇我们介绍了UIE，它采用了文本-结构、seq2seq的生成方法。这一方法具有\u0026quot;黑盒\u0026quot;特性，信息片段(如实体、关系、关键词等)和模式(如输出结构)之间的关联是隐式的，这可能导致以下问题：\n由于模型在生成过程中不显式地展示哪些信息片段与模式相关联，因此难以判断模型学到了哪些知识。无法判断它是否真正理解了实体关系，还是仅仅是在模拟训练数据的表面模式。 由于信息片段和生成模式的关联是隐式的，在迁移到新的任务或模式时，模型是否能够正确应用已有知识变得难以预测。 Note：输入的信息被编码器编码成一组上下文向量，这些向量包含了输入的所有信息。但这些向量本身是高度抽象的，并没有显式地表示出输入中的特定信息片段(如重要的实体或关系)。而输出的每一步依赖于隐含的上下文向量和之前的输出，这种生成方式也没有显式地表现模型是如何将某些输入信息片段映射到具体的输出部分的。由于这些关联是隐含的，很难解释模型在生成过程中是如何决策的。例如，模型可能在输出中提到了某个关键实体，但难以追踪它是根据哪个输入信息片段得出的。\n因此，作者认为，为了确保有效、稳健和可解释的迁移能力，显式建模和学习可迁移的知识是必要的。\nUnified Semantic Matching via Directed Token Linking Schema-Text Joint Embedding 为了让模型理解标签模式(schema)和文本之间的关联(同时捕捉标签和文本之间的语义关系)，USM对提取模式(schema)和文本token进行共同编码，从而生成它们的联合上下文嵌入：\n提取模式词序列化：USM将提取模式(schema)表示为一个词序列。例如，如果提取模式是\u0026quot;person\u0026quot;和\u0026quot;location\u0026quot;这样的标签，USM会将这些标签转换为词序列形式，即{$l_1,l_2,\u0026hellip;,l_{|l|}$}。(类似文本token) 拼接schema和文本：USM将词序列化后的schema sequence与文本token{$t_1,t_2,\u0026hellip;,t_{|t|}$}进行拼接，一起作为模型的输入。 Transformer编码器：拼接后的词序列和文本通过一个Transformer编码器进行处理，计算出联合的上下文嵌入H，表示为$[h_1,h_2,\u0026hellip;,h_{|l|+|t|]$。 Mask矩阵：M是一个Mask矩阵，用来决定哪些标签或文本token可以互相\u0026quot;看到\u0026quot;(self-attention)，从而捕捉它们之间的交互关系。 最终，联合标签-文本嵌入可以表示为： $$ H = Encoder(l_1,l_2,...,l_{|l|},t_1,t_2,...,t_{|t|},M) $$Token Linking Operations 要实现UIE，还是要对不同IE任务进行统一建模。\n类似UIE的定位(Spotting)和关联(Associating)，作者将IE任务解耦为两个操作：\n结构化(Structuring)：从文本中抽取出与标签无关的基本子结构。例如，实体抽取\u0026quot;Monet\u0026quot;；事件触发词\u0026quot;born in\u0026quot;；关系实体对(\u0026ldquo;Monet\u0026rdquo;，\u0026ldquo;Paris\u0026rdquo;)；事件论元(\u0026ldquo;born in\u0026rdquo;，\u0026ldquo;Paris\u0026rdquo;)。 概念化(Conceptualizing)：在概念化阶段将这些具体子结构与语义标签相连接。例如：\u0026ldquo;Monet\u0026quot;可以标记为\u0026quot;person\u0026rdquo;。 其中，结构化通过Token-Token Linking (TTL)操作实现，概念化通过Label-Token Linking (LTL)和Token-Label Linking (TLL)操作实现。\nToken-Token Linking for Structuring (TTL) 前面我们提到，结构化的目标是要提取出文本中的基本信息单元(如实体、关系、触发词等)。这些基本信息单元是一组连续的token序列，我们需要知道单个信息单元是从哪里开始、又从哪里结束。\n而部分IE任务所需的结构可能包括不止一个信息单元，例如{\u0026ldquo;Monet\u0026rdquo;, birth place, \u0026ldquo;Paris\u0026rdquo;}就是一个三元组的形式，此时，我们则需要找到Subject-Object对。\n作者设计了TTL操作，从两个方面对输入文本中所有有效的子结构进行构造：\nUtterance(文本)：指输入文本中的连续token序列，例如实体(如\u0026quot;Monet\u0026quot;)或事件触发词(如\u0026quot;born in\u0026quot;)。 如图所示，其实就是将头和尾链接(H2T)。例如，为了提取span\u0026quot;Monet\u0026quot;和\u0026quot;born in\u0026quot;作为有效的子结构，USM利用H2T将\u0026quot;Monet\u0026quot;链接到自身来提取\u0026quot;Monet\u0026quot;，并将\u0026quot;born\u0026quot;链接到\u0026quot;in\u0026quot;以提取\u0026quot;born in\u0026quot;。 Association Pair(文本对)：从文本中提取的基本关联对单元，例如关系的Subject-Object对(如\u0026quot;Monet\u0026quot;和\u0026quot;Paris\u0026quot;)或事件触发词-参数对(如\u0026quot;born in\u0026quot;和\u0026quot;Paris\u0026quot;)。 如图所示，链接关联对是将头与头链接(H2H)、尾与尾链接(T2T)。例如，要提取Subject-Object对\u0026quot;Monet\u0026quot;和\u0026quot;Paris\u0026quot;，USM通过H2H将\u0026quot;Monet\u0026quot;和\u0026quot;Paris\u0026quot;链接起来，同时也通过T2T链接这两个token。 USM通过计算每对有效token对$\u0026lt;t_i,t_j\u0026gt;$的链接分数$s_{TTL}(t_i,t_j)$(表示token之间的相似度或相关性，高分数意味着这两个token在上下文中有较强的关联性，适合进行链接)来实现上述的H2T、H2H和T2T链接操作。链接分数的计算公式如下：\n$$ s_{TTL}(t_i,t_j) = FFNN_{TTL}^l(h_t^i)^TR_{j-i}FFNN_{TTL}^r(h_t^j) $$ 其中，FFNN为前馈神经网络层，用于处理token的嵌入信息。$R_{j-i}$是一个旋转位置嵌入(用于编码token之间的相对位置关系)。通过这种方式，模型可以捕捉到token之间的相对位置关系。\nLabel-Token Linking for Utterance Conceptualizing (LTL) 结构化是从Utterance和Association Pair两个方面来进行处理的，概念化也是如此。首先考虑Utterance的概念化，包括两种类型：\nType of Mention：将标签类型直接分配给span。例如，将实体\u0026quot;Monet\u0026quot;标记为类型\u0026quot;person\u0026quot;，\u0026ldquo;France\u0026quot;标记为类型\u0026quot;country\u0026rdquo;。 Predicate of Object：将关系标签分配给Association Pair中的Object。例如，\u0026ldquo;Paris\u0026quot;的关系类型\u0026quot;birth place\u0026rdquo;，事件参数类型\u0026quot;capital\u0026quot;。 用label-to-head(L2H)和label-to-tail(L2T)链接操作来为每个子结构分配标签(其实也是头对头、尾对尾，只是不是将信息单元进行链接了，而是将标签与信息单元进行链接)。链接分数的计算公式如下： $$ s_{LTL}(l_i,t_j) = FFNN_{LTL}^{label}(h_i^l)^TR_{j-i}FFNN_{LTL}^{Text}(h_j^t) $$ Token-Label Linking for Pairing Conceptualizing (TLL) 考虑Association Pair的概念化。在LTL中，已经链接了label到Association Pair中的Object，还需要链接label和Association Pair中的Subject。这样就可以根据多条路径确定一个三元组：\nTTL：(Subject, Object)\nLTL：(Association, Object)\nTLL：(Subject, Association)\n链接方式与LTL类似，还是头对头、尾对位的链接，但链接方向不同，链接通过head-to-label(H2L)和tail-to-label(T2L)实现。链接分数的计算公式如下： $$ s_{TTL}(t_i,l_j) = FFNN_{TLL}^{text}(h_i^l)^TR_{j-i}FFNN_{TLL}^{label}(h_j^t) $$Schema-Text Joint Embedding 通过schema-constraint解码，如图所示：\n通过TTL操作提取的内容：例如，{\u0026ldquo;Monet\u0026rdquo;, \u0026ldquo;Paris\u0026rdquo;, \u0026ldquo;France\u0026rdquo;, (\u0026ldquo;Monet\u0026rdquo;, \u0026ldquo;Pairs\u0026rdquo;), (\u0026ldquo;France\u0026rdquo;, \u0026ldquo;Pairs\u0026rdquo;)}，抽取得到\u0026quot;Monet\u0026quot;和\u0026quot;Paris\u0026quot;，以及Subject-Object对(\u0026ldquo;Monet\u0026rdquo;, \u0026ldquo;Paris\u0026rdquo;)和(\u0026ldquo;France\u0026rdquo;, \u0026ldquo;Paris\u0026rdquo;)。 通过LTL操作提取的内容：例如，{(person, \u0026ldquo;Monet\u0026rdquo;), (country, \u0026ldquo;France\u0026rdquo;), (birth place, \u0026ldquo;Paris\u0026rdquo;), (capital, \u0026ldquo;Paris\u0026rdquo;)}，每个label(如person、country)都与相应的Object(如\u0026quot;Monet\u0026quot;、\u0026ldquo;France\u0026rdquo;)相关联。 通过TLL操作提取的内容：例如，(\u0026ldquo;Monet\u0026rdquo;, birth place), (\u0026ldquo;France\u0026rdquo;, capital)，将Subject与其相应的关系label(如birth place、capital)联系起来。 基于获得的label-token间的链接(例如\u0026quot;Monet\u0026quot;与\u0026quot;birth place\u0026quot;以及\u0026quot;France\u0026quot;与\u0026quot;capital\u0026quot;)，USM能够一致地生成完整的结构，例如：(\u0026ldquo;Monet\u0026rdquo;, birth place, \u0026ldquo;Paris\u0026rdquo;)和(\u0026ldquo;France\u0026rdquo;, capital, \u0026ldquo;Paris\u0026rdquo;)。 这些解码步骤之间是独立的，这意味着提取操作是完全非自回归的(non-autoregressive)，这使得解码过程可以并行进行。\nLearning from Heterogeneous Supervision USM使用了标签的词序列化表示(verbalized label representation)和统一的token链接机制，不论资源的来源或类型如何，USM将它们统一表示为\u0026lt;text, token pairs\u0026gt;进行预训练。\nPre-training 异构监督资源(来源不同、类型多样的训练数据)包括任务注释信号(例如，IE数据集)、远程信号(例如，远程监督数据集)和间接信号(例如，QA数据集)三种不同类型：\n$D_{task}$(任务标注数据集)\n其中每个实例都有一个用于信息提取的标准注释。本文使用在信息提取领域广泛使用的Ontonotes作为标准注释，它包含18种实体类型。 任务标注数据集用于帮助模型学习任务特定的结构化和概念化能力。即通过这些标注数据，模型可以学习如何准确地从文本中提取特定类型的实体和关系。 $D_{distant}$(远程监督数据集)\n远程监督数据集是通过将文本与知识库对齐来生成的标注数据。本文使用NYT和Rebel作为远程监督数据集，这些数据集分别是通过将文本与Freebase和Wikidata对齐而获得。由于Rebel数据集的标签模式过长，不适合直接与输入文本拼接并输入到预训练的Transformer编码器中。因此，本文采样了负标签(与输入文本的实际内容没有对应关系的标签)模式构建meta schema，简化预训练时的标签模式。 远程监督数据为模型提供大规模的训练数据，帮助模型学习广泛的结构和概念化能力。 $D_{indirect}$(间接监督数据集)\n间接监督数据集来自与信息抽取相关的其他NLP任务，主要是阅读理解数据集。本文使用MRQA中的阅读理解数据集，如HotpotQA、Natural Questions、NewsQA、SQuAD、TriviaQA等。 间接监督数据集通过多样化的问题表达，提供了比$D_{task}$和$D_{distant}$更多样化的标签语义信息，有助于模型学习更丰富的概念化能力(增强泛化能力)。对于每个(question，context，answer)实例，问题作为label schema，context作为输入文本，answer作为mention。 Learning function 在USM学习过程中，面临的主要挑战是链接对的稀疏性(链接对仅占所有有效标记对候选项的不到1%)，为了应对这种极端的链接实例稀疏性，USM使用了优化的类别不平衡损失。 $$ L = \\sum_{m \\in \\mathcal{M}} log \\left(1+\\sum_{(i, j) \\in m^{+}} e^{-s_{m}(i, j)}\\right) +\\log \\left(1+\\sum_{(i, j) \\in m^{-}} e^{s_{m}(i, j)}\\right) $$ 损失函数由两部分组成：\n针对已链接对$m^+$的损失，利用链接评分$s_m (i,j)$来计算概率，增加与正样本的联系。 针对未链接对$m^-$的损失，同样基于链接评分，但通过对未链接的对进行惩罚，降低其影响。 Experiments 对比USM和其他SOTA模型在4个任务的13个数据集上的性能。AVE-unify表示非重叠数据集的平均性能，AVE-total表示所有数据集的平均性能。USM实现了SOTA，在不使用预训练模型的情况下，用RoBERTa初始化的USM框架也表现出了较好的效果。\n在不同领域的9个数据集上进行zero-shot实验。即使从实体类型有限的$D_{task}$中学习，USM在电影、文学和音乐领域也表现出良好的迁移性能。$D_{distant}$和$D_{indirect}$在预训练过程中有重要作用。\nUSM(356M)以较小的模型大小优于强zero-shot基线GPT-3(175B)和DEEPSTRUCTURE(10B)。\n(详细的实验结果和分析可以查看原文)\nConclusion 提出了一个统一的语义匹配框架——USM。 UIE方法未能显式地展示信息片段与模式的关联、知识迁移效果难以预测 ——\u0026gt; USM通过结构化和概念化显式地建立了信息片段与标签之间的关联\n(例如，当迁移到新任务时，USM不需要重新学习基本的信息抽取能力，而是只需要在新领域中重新定义或调整概念化标签。这种显式关联使得知识的迁移更加系统化，减少了模型在新任务中的不确定性) USM在监督实验下达到了最先进的性能，在zero/few shot设置下表现出很强的泛化能力。 References [1] https://blog.csdn.net/qq_27590277/article/details/128699655?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522A7AAA045-C8D2-470D-8CB4-6FB0D7220C7D%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D\u0026request_id=A7AAA045-C8D2-470D-8CB4-6FB0D7220C7D\u0026biz_id=0\u0026utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-128699655-null-null.142^v100^pc_search_result_base1\u0026utm_term=Universal%20Information%20Extraction%20as%20Unified%20Semantic%20Matching\u0026spm=1018.2226.3001.4187\n[2] https://adaning.github.io/posts/11838.html\n","date":"2024-11-03T09:27:34+08:00","image":"https://JLING-L.github.io/p/%E9%80%9A%E7%94%A8%E4%BF%A1%E6%81%AF%E6%8A%BD%E5%8F%962-universal-information-extraction-as-unified-semantic-matching/cover_hu16461630435969615153.jpg","permalink":"https://JLING-L.github.io/p/%E9%80%9A%E7%94%A8%E4%BF%A1%E6%81%AF%E6%8A%BD%E5%8F%962-universal-information-extraction-as-unified-semantic-matching/","title":"通用信息抽取2 | Universal Information Extraction as Unified Semantic Matching"},{"content":" 论文：https://arxiv.org/abs/1503.03585\nUnified Structure Generation for Universal Information Extraction ","date":"2024-11-01T22:18:33+08:00","image":"https://JLING-L.github.io/p/%E6%89%A9%E6%95%A3%E6%A8%A1%E5%9E%8B1-deep-unsupervised-learning-using-nonequilibrium-thermodynamics/cover_hu15906455351157683626.jpg","permalink":"https://JLING-L.github.io/p/%E6%89%A9%E6%95%A3%E6%A8%A1%E5%9E%8B1-deep-unsupervised-learning-using-nonequilibrium-thermodynamics/","title":"扩散模型1 | Deep Unsupervised Learning using Nonequilibrium Thermodynamics"},{"content":" 论文：https://arxiv.org/abs/2203.12277\n代码：https://github.com/universal-ie/UIE\nAccepted to the main conference of ACL2022\n什么是信息抽取？\n我们首先简单介绍一下信息抽取，有了解的可以直接跳过。\n信息抽取(Information Extraction, IE)是自然语言处理(NLP)领域的一个任务，旨在从非结构化的文本数据中自动识别并提取结构化的信息，例如提取文本中的关键实体、关系或事件等。主要关注三个任务：\n例：Steve became CEO of Apple in 1997.\n命名实体识别(Named Entity Recognition, NER)\nNER任务的目标是识别文本中的实体(如人名、地点、组织等)并分类。对于上面给出的例句，识别实体\u0026quot;Steve\u0026quot;，类型标注为\u0026quot;person\u0026quot;；识别实体\u0026quot;Apple\u0026quot;，类型标注为\u0026quot;organization\u0026quot;；识别实体\u0026quot;1997\u0026quot;，类型标注为\u0026quot;time\u0026quot;。 关系抽取(Relation Extraction)\nRE任务的目标是识别文本中的实体关系，明确它们之间的联系。对于上面给出的例句，头实体\u0026quot;Steve\u0026quot;，尾实体\u0026quot;Apple\u0026quot;，他们之间的关系为\u0026quot;work-for\u0026quot;。 事件抽取(Event Extraction)\nEE任务的目标是识别文本中发生的事件，并提取出事件的参与实体、时间、地点等信息(事件参数)。对于上面给出的例句，识别触发词\u0026quot;became\u0026quot;，类型标注为\u0026quot;start-position\u0026quot;。事件下对应的三个论元\u0026quot;Steve\u0026quot;，\u0026ldquo;Apple\u0026rdquo;，\u0026ldquo;1997\u0026quot;分别扮演\u0026quot;employee\u0026rdquo;，\u0026ldquo;employer\u0026rdquo;，\u0026ldquo;time\u0026quot;的事件角色。 可以看出，对于不同的IE任务，随着任务目标的变化，需要抽取出的信息的结构也各有不同，例如在NER中要抽取出的是句子中的单词或短语，在RE任务中又需要判断两个实体间的关系。\n因此要完成不同的任务，就需要定义不同的抽取模式(即信息抽取时需要遵循的结构化规则或框架)。\n但可以观察到，这几个任务之间其实是有共通之处的，比如RE，就可以看作是NER任务的进一步扩展。\n是否有办法对这三个任务进行统一建模？\n下面我们来看一下UIE这篇文章。\nUnified Structure Generation for Universal Information Extraction IE受到其不同目标、异构结构和特定需求模式的影响，此前大多数IE方法都是为不同的任务设计不同的模型，这存在几个问题：\n为大量的IE任务/设置/场景开发专用架构非常复杂(比如单独设计一个模型，专门处理RE任务；单独设计一个模型，专门处理EE任务，听起来就很麻烦)。 学习孤立的模型严重限制了相关任务和设置之间的知识共享(比如RE任务，NER任务中实体已经抽取好了、类别也标注好了，为什么不能直接用呢)。 构建专门用于不同IE任务的数据集和知识源既昂贵又耗时(不同任务的数据集的知识是不是可以共享呢)。 作者认为，所有IE任务都可以建模为文本到结构(text-to-structure)的转换。\nStructured Extraction Language for Uniform Structure Encoding (SEL) 首先，要将不同的IE结构编码成统一的表示，这样就可以在同一个文本-结构的生成框架中对各种IE任务进行统一建模。具体而言，作者将这一转换过程拆分为了两个子操作：\n例：Steve works for Apple.\n定位(Spotting)：在文本中找到特定语义类型的span，将文本中的特定span根据预先定义的语义类型进行标注。例：\u0026ldquo;Steve\u0026quot;被标注为\u0026quot;Person\u0026rdquo;。 关联(Associating)：对已经定位的span进行关联(例如标记实体对之间的关系)。例：将\u0026quot;Steve\u0026quot;标记为Arg1，\u0026ldquo;Apple\u0026quot;标记为Arg2(类似将\u0026quot;Steve\u0026quot;视为头实体，\u0026ldquo;Apple\u0026quot;视为尾实体)。关联Arg1和Arg2，即判断这两个实体之间的关系，我们将关系标注为\u0026quot;Work-for\u0026rdquo;。 作者使用Spot Name和Asso Name分别表示Spotting和Associating操作。Info Span则表示Spot Name和Asso Name所标记的实际文本信息。\n我们来看作者给出的一个具体示例。\n例：对于文本输入\u0026quot;Steve became CEO of Apple in 1997.\u0026quot;，通过SEL生成的结构：\nRE(蓝色)：头实体\u0026quot;Steve\u0026rdquo;(Info Span)，类型标注为\u0026quot;person\u0026rdquo;(Spot Name)；尾实体\u0026quot;Apple\u0026quot; (Info Span)，类型标注为\u0026quot;organization\u0026quot;(Spot Name)；关系\u0026quot;work-for\u0026quot;(Asso Name)。 EE(红色)：触发词\u0026quot;became\u0026quot;(Info Span)，类型标注为\u0026quot;start-position\u0026quot;(Spot Name)。事件下对应的三个论元\u0026quot;Steve\u0026quot; (Info Span)，\u0026ldquo;Apple\u0026rdquo; (Info Span)，\u0026ldquo;1997\u0026rdquo; (Info Span)分别扮演\u0026quot;employee\u0026quot;(Spot Name)，\u0026ldquo;employer\u0026rdquo;(Spot Name)，\u0026ldquo;time\u0026rdquo;(Spot Name)的事件角色。 NER(黑色)：实体\u0026quot;Steve\u0026quot;(Info Span)，类型标注为\u0026quot;person\u0026quot;(Spot Name)；实体\u0026quot;Apple\u0026quot; (Info Span)，类型标注为\u0026quot;organization\u0026quot;(Spot Name)；实体\u0026quot;1997\u0026quot; (Info Span)，类型标注为\u0026quot;time\u0026quot;(Spot Name)。 这样一来，无论对二元关系，还是N元论元结构，都可以用SEL语法表示。\nStructural Schema Instructor for Controllable IE Structure Generation (SSI) 虽然三个IE任务都可以通过SEL统一表示结构，但模型还不知道什么时候该做什么。\n作者设计了特殊符号[spot], [asso]和[text]，分别添加到每个Spot Name、Asso Name和输入文本序列之前，来提示模型要提取哪些信息。\n具体的例子如图所示，类似于给一个表格让模型去填写表格内容。\n但当需要提取出的信息较多、句子结构比较复杂的情况下，输入序列会变得非常长：\nStructure Generation with UIE 简单来说，UIE的输入是SSI+Text的形式，输出是用SEL语法表示的结构。UIE整体可以看作是Encoder-Decoder架构的模型：\nEncoder 通过Transformer Encoder对SSI $s$和文本序列$x$进行编码，生成hidden representation: $$ H = Encoder(s_1, s_2, s_{|s|}, x_1, ..., x_{|x|}) $$Decoder 使用Transformer Decoder以自回归的方式逐步生成目标SEL序列： $$ y_i, h_i^d = Decoder([H; h_1^d, ..., h_{i-1}^d]) $$ 当解码器生成特殊的结束符号\u0026lt;eos\u0026gt;时，解码过程完成。\n作者认为，文本-结构的生成范式将标签视为自然语言标记，这一方法可以有效地转移来自BART、T5等预训练语言模型的知识，相关任务可以很容易地共享知识，因为它们的标签具有相似的语义(例如，location和place)，并共享共同的标签-文本关联(例如，不同事件类型的受害者)。\nPre-training for UIE 预训练数据集 包括结构化(例如，知识库)、非结构化(例如，原始文本)和并行(例如，维基百科-维基数据链接)数据：\n$D_{record}$(结构)：$D_{record}$是一个结构数据集，每个实例是一个结构化记录$y$。该数据集从ConceptNet(一个常识知识库)和Wikidata中收集结构化记录。$D_{record}$用于预训练UIE的结构解码能力，帮助模型在理解结构化记录后，能够从这些记录生成有效的输出。 $D_{text}$(文本)：$D_{text}$是一个非结构化文本数据集，包含英语维基百科中的所有纯文本。$D_{text}$用于预训练UIE的语义编码能力。通过对大规模的非结构化文本进行训练，模型能够更好地理解自然语言的语义、上下文和结构特征。 $D_{pair}$(文本+结构)：$D_{pair}$是文本-结构的并行数据集，每个实例由一对$(token序列x，结构化记录y)$组成。Dpair用于预训练UIE的文本到结构转换能力，使模型能够理解和处理文本与其对应结构之间的关系。 预训练任务 使用三个序列生成任务来预训练UIE：\nText-to-Structure Pre-training using $D_pair$：$p(y|x,s_meta)$表示在给定文本和模式的条件下生成结构记录$y$的概率。 $$ {L}_{\\text {Pair}}=\\sum_{(x, y) \\in \\mathcal{D}_{\\text {pair}}}-\\log p\\left(y \\mid x, s_{\\text {meta}} ; \\theta_{e}, \\theta_{d}\\right) $$ Structure Generation Pre-training with $D_record$：在给定之前生成的token的情况下，预测当前token $y_i$的负对数似然。 $$ {L}_{\\text {Record}}=\\sum_{y \\in \\mathcal{D}_{\\text {record}}}-\\log p\\left(y_i \\mid y_{\u0026lt i}; \\theta_{d}\\right) $$ Retrofitting Semantic Representation using $D_text$：给定被Mask的源文本，让模型还原被Mask的部分。 $$ {L}_{\\text {Text}}=\\sum_{x \\in \\mathcal{D}_{\\text {text}}}-\\log p\\left(x^{\\prime \\prime} \\mid x^{\\prime} ; \\theta_{e}, \\theta_{d}\\right) $$ 最终目标是将上述任务结合起来： $$ {L}={L}_{\\text {Pair}} + {L}_{\\text {Record}} + {L}_{\\text {Text}} $$Fine-tuning for UIE 给定一个标记语料库$D_task={(s, x, y)}$，使用teacher-forcing cross-entropy loss来微调UIE模型： $$ {L}_{FT}=\\sum_{(s, x, y) \\in \\mathcal{D}_{\\text {Task}}}-\\log p\\left(y \\mid x, s; \\theta_{e}, \\theta_{d}\\right) $$ 为了缓解暴露偏差，在解码过程中，作者还设计了一种拒绝机制。给定实例$(s, x, y)$，使用SEL对$y$进行编码，随机加入$[NULL]$噪声。具体示例如图所示：\n句子中没有facility实体，在模型学习时随机注入\u0026quot;(facility：[NULL])\u0026ldquo;的噪声。通过这种方式，UIE可以通过生成[NULL]来有效地学习拒绝误导生成。\nExperiment 可以看到，UIE在多个任务上SOTA。\nps：其他的实验结果具体可以看原文，在这里就不详细说明了。\nConclusion 提出了一个统一的文本到结构生成框架——UIE(T5+结构化生成)，它可以通用地建模不同的IE任务，自适应地生成有针对性的结构，并从不同的知识源中学习通用的IE能力：\n多样化的目标结构 \u0026mdash;\u0026gt; SEL统一编码异构抽取结构 需求特定的抽取模式 \u0026mdash;\u0026gt; 基于模式的提示机制SSI 不同任务之间知识难以共享 \u0026mdash;\u0026gt; 在包含多个任务的数据集上预训练模型 ","date":"2024-10-30T16:37:14+08:00","image":"https://JLING-L.github.io/p/%E9%80%9A%E7%94%A8%E4%BF%A1%E6%81%AF%E6%8A%BD%E5%8F%961-unified-structure-generation-for-universal-information-extraction/uie_framwork_hu3983124210947955712.jpg","permalink":"https://JLING-L.github.io/p/%E9%80%9A%E7%94%A8%E4%BF%A1%E6%81%AF%E6%8A%BD%E5%8F%961-unified-structure-generation-for-universal-information-extraction/","title":"通用信息抽取1 | Unified Structure Generation for Universal Information Extraction"}]